1. 事务隔离级别
    1. 读未提交 一个事务为提交,其他事务就能看到数据变更的情况
    2. 读提交 其他事务看到数据变更的情况需要在那个事务提交之后才能看到
    3. 可重复读 一个事务内看到数据始终和事务开启时的一样
    4. 串行化 事务对数据的修改是通过加锁来确定先手顺序的（包括读锁和写锁）
2. 数据库锁的分类: 全局锁, 表级锁, 行锁
   1. 全局锁的使用场景: 方法 FTWRL(flush tables with read lock?) 一般作为全库逻辑备份,所有数据的增删改无法进行
   ，表结构的定义操作无法进行，更新类的事务操作无法进行
   需要说明的：全库逻辑备份可能带来的问题：
      1. 主库备份的话： 主库备份期间是只读状态，其他更新，变更操作无法进行下去，相当于“宕机”状态中。这在实际场景中可能是无法接受的。
      2. 从库备份的话： 主库和从库之间可能存在延迟，因为在从库备份期间，主库同步的binlog数据无法同步，导致主从之间的数据有不一致的情况出现，主从之间存在延迟的现象。
   关于逻辑备份，可以用可重复读的事务隔离级别下开启，开启备份的时候开启事务，这样在备份期间是可以保证数据是可以更新的。mysql的mysqldump就是就dump数据的时候开启了single-transaction
   2. 表级锁 表级别的锁有两种，一种是表锁 一种是元数据锁（MetaData Lock）
      1. 表级别锁是锁定表的一种锁，lock tables t read/write 然后表级别锁加上之后可能会影响当前线程的读写以及其他线程的读写。如：当前线程加了表锁的read的话，当前线程不可以进行该表的写，只能进行该表的读。其他线程不能对该表进行读写。 需要说明的是：INNODB一般加锁是给索引加锁，如果没有索引的时候才会升级成表锁，表锁使用会影响性能
      一般慎用表锁，ISAM不支持行锁，就考虑换成其他支持的引擎，如INNODB。
      2. MDL锁，在执行相关操作的时候系统自动会加上。一般是为了保证DML和DDL操作之间不影响。MDL锁 读读不排斥 读写互斥 写写互斥。 当要进行DDL操作的时候最好能
      看下当前情况下是否有长事务，且该长事务中有对该表的DML操作。有的话可以考虑kill该长事务或者暂时不进行改DDL操作。原因：长事务持有MDL读锁，然后在进行DDL的时候
      需要持有MDL写锁，读写互斥需要相互等待，这时候DDL操作在等待的时候，因为优先级比较高，就会阻塞住后面的相关MDL读锁，即对该表进行增删改查。如果有错误重发的机制，在频繁
      查询的时候，就可能导致数据库直接连接池被占满，搞崩数据库。
      解决方案： 尽量避免长事务的情况，且在进行DDL操作的时候加上等待时间，保证DDL持有MDL写锁的时间不要过长，这样不影响后面的MDL读锁的持有。
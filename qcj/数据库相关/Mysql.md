1. 事务隔离级别
    1. 读未提交 一个事务为提交,其他事务就能看到数据变更的情况
    2. 读提交 其他事务看到数据变更的情况需要在那个事务提交之后才能看到
    3. 可重复读 一个事务内看到数据始终和事务开启时的一样
    4. 串行化 事务对数据的修改是通过加锁来确定先手顺序的（包括读锁和写锁）
2. 数据库锁的分类: 全局锁, 表级锁, 行锁
   1. 全局锁的使用场景: 方法 FTWRL(flush tables with read lock?) 一般作为全库逻辑备份,所有数据的增删改无法进行
   ，表结构的定义操作无法进行，更新类的事务操作无法进行
   需要说明的：全库逻辑备份可能带来的问题：
      1. 主库备份的话： 主库备份期间是只读状态，其他更新，变更操作无法进行下去，相当于“宕机”状态中。这在实际场景中可能是无法接受的。
      2. 从库备份的话： 主库和从库之间可能存在延迟，因为在从库备份期间，主库同步的binlog数据无法同步，导致主从之间的数据有不一致的情况出现，主从之间存在延迟的现象。
   关于逻辑备份，可以用可重复读的事务隔离级别下开启，开启备份的时候开启事务，这样在备份期间是可以保证数据是可以更新的。mysql的mysqldump就是就dump数据的时候开启了single-transaction
   2. 表级锁 表级别的锁有两种，一种是表锁 一种是元数据锁（）